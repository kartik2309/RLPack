<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RLPack: C_RolloutBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="RLPack-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">RLPack
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_c___rollout_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle"><div class="title">C_RolloutBuffer Class Reference<div class="ingroups"><a class="el" href="group__binaries__group.html">binaries</a> &raquo; <a class="el" href="group__rollout__buffer__group.html">rollout_buffer</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The class <a class="el" href="class_c___rollout_buffer.html" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer....">C_RolloutBuffer</a> is the class that implements the C++ backend for Rollout Buffer. Tensors are moved to C++ backend via PyBind11 and are kept opaque with std::map, hence, tensors are moved between Python and C++ only by references. <code><a class="el" href="class_c___rollout_buffer.html" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer....">C_RolloutBuffer</a></code> is hence autograd safe.  
 <a href="class_c___rollout_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c___rollout_buffer_8h_source.html">C_RolloutBuffer.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for C_RolloutBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_c___rollout_buffer__coll__graph.png" border="0" usemap="#a_c___rollout_buffer_coll__map" alt="Collaboration graph"/></div>
<map name="a_c___rollout_buffer_coll__map" id="a_c___rollout_buffer_coll__map">
<area shape="rect" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer...." alt="" coords="25,93,140,119"/>
<area shape="rect" href="class_rollout_buffer_container.html" title="The class RolloutBufferContainer is the main backend container that is used in C_RolloutBuffer...." alt="" coords="5,5,160,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2369413382be0e3418db567c04d3b5cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">DataLoader</a> = torch::disable_if_t&lt; false, std::unique_ptr&lt; torch::data::StatelessDataLoader&lt; torch::data::datasets::MapDataset&lt; <a class="el" href="class_rollout_buffer_batch.html">RolloutBufferBatch</a>, <a class="el" href="class_rollout_buffer_batch_transform.html">RolloutBufferBatchTransform</a> &gt;, torch::data::samplers::SequentialSampler &gt; &gt; &gt;</td></tr>
<tr class="memdesc:a2369413382be0e3418db567c04d3b5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Torch DataLoader unique pointer type for RolloutBuffer.  <a href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">More...</a><br /></td></tr>
<tr class="separator:a2369413382be0e3418db567c04d3b5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a244889898ec240c4d2aef923dbbf2ea3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a244889898ec240c4d2aef923dbbf2ea3">C_RolloutBuffer</a> (int64_t bufferSize, std::string &amp;device, std::string &amp;dtype, std::map&lt; std::string, c10::intrusive_ptr&lt; c10d::ProcessGroup &gt; &gt; &amp;processGroupMap, const std::chrono::duration&lt; int32_t &gt; &amp;workTimeoutDuration)</td></tr>
<tr class="separator:a244889898ec240c4d2aef923dbbf2ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6688e63ed6b81b72e324097e306415f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a6688e63ed6b81b72e324097e306415f0">clear_policy_outputs</a> ()</td></tr>
<tr class="separator:a6688e63ed6b81b72e324097e306415f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7329ae83788c6abdfd97e7bf65d24f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a3d7329ae83788c6abdfd97e7bf65d24f">clear_transitions</a> ()</td></tr>
<tr class="separator:a3d7329ae83788c6abdfd97e7bf65d24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d66284b9689a3e1582e742d091a71fb"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a8d66284b9689a3e1582e742d091a71fb">compute_discounted_td_residuals</a> (float_t gamma)</td></tr>
<tr class="separator:a8d66284b9689a3e1582e742d091a71fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edf043bd971020b94de504d1861d300"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a7edf043bd971020b94de504d1861d300">compute_generalized_advantage_estimates</a> (float_t gamma, float_t gaeLambda)</td></tr>
<tr class="separator:a7edf043bd971020b94de504d1861d300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2ac0c8ffb12fb423b851013134e8be"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#aeb2ac0c8ffb12fb423b851013134e8be">compute_returns</a> (float_t gamma)</td></tr>
<tr class="separator:aeb2ac0c8ffb12fb423b851013134e8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4541bcd75daf31012ea961f3b5316b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a6e4541bcd75daf31012ea961f3b5316b">extend_transitions</a> ()</td></tr>
<tr class="separator:a6e4541bcd75daf31012ea961f3b5316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbf19066e59d0fd0639d129a8304d79"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a2dbf19066e59d0fd0639d129a8304d79">get_action_log_probabilities_statistics</a> ()</td></tr>
<tr class="separator:a2dbf19066e59d0fd0639d129a8304d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce17ba7cf35388670e89fd4d8cd311"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#af9ce17ba7cf35388670e89fd4d8cd311">get_advantage_statistics</a> (float_t gamma, float_t gae_lambda)</td></tr>
<tr class="separator:af9ce17ba7cf35388670e89fd4d8cd311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b0c0ef25050dd36acffff7e92b3999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">DataLoader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a59b0c0ef25050dd36acffff7e92b3999">get_dataloader_reference</a> ()</td></tr>
<tr class="separator:a59b0c0ef25050dd36acffff7e92b3999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8703acf21b67108244b091f4cb39fff8"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a8703acf21b67108244b091f4cb39fff8">get_entropy_statistics</a> ()</td></tr>
<tr class="separator:a8703acf21b67108244b091f4cb39fff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb842c456059fb4eacb728259f197c1d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#aeb842c456059fb4eacb728259f197c1d">get_stacked_action_log_probabilities</a> ()</td></tr>
<tr class="separator:aeb842c456059fb4eacb728259f197c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae867164b2f37aaa3becb98869e2e769f"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#ae867164b2f37aaa3becb98869e2e769f">get_stacked_dones</a> ()</td></tr>
<tr class="separator:ae867164b2f37aaa3becb98869e2e769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6db4b52e8668ec29c03ce694670bd06"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#ac6db4b52e8668ec29c03ce694670bd06">get_stacked_entropies</a> ()</td></tr>
<tr class="separator:ac6db4b52e8668ec29c03ce694670bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac46b846924e49fb0d7aa8f0e826e72"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a9ac46b846924e49fb0d7aa8f0e826e72">get_stacked_rewards</a> ()</td></tr>
<tr class="separator:a9ac46b846924e49fb0d7aa8f0e826e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4f5e54a312a96e9c37565add2af9e2"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#acb4f5e54a312a96e9c37565add2af9e2">get_stacked_state_current_values</a> ()</td></tr>
<tr class="separator:acb4f5e54a312a96e9c37565add2af9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff648bf43f074d9b01b335a06e7ffd6"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a8ff648bf43f074d9b01b335a06e7ffd6">get_stacked_state_next_values</a> ()</td></tr>
<tr class="separator:a8ff648bf43f074d9b01b335a06e7ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373ba6bdf959906f03049935ab009b73"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a373ba6bdf959906f03049935ab009b73">get_stacked_states_current</a> ()</td></tr>
<tr class="separator:a373ba6bdf959906f03049935ab009b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857c91f65f5ff1472b229df37d3b4266"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a857c91f65f5ff1472b229df37d3b4266">get_stacked_states_next</a> ()</td></tr>
<tr class="separator:a857c91f65f5ff1472b229df37d3b4266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8f798966744c77a3bc2adf046e11f0"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a3e8f798966744c77a3bc2adf046e11f0">get_state_values_statistics</a> ()</td></tr>
<tr class="separator:a3e8f798966744c77a3bc2adf046e11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb048dff5319659dfaa225eabe33838"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a8fb048dff5319659dfaa225eabe33838">get_states_statistics</a> ()</td></tr>
<tr class="separator:a8fb048dff5319659dfaa225eabe33838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610469447ea8a72912d9ba0117809363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a610469447ea8a72912d9ba0117809363">insert_policy_output</a> (std::map&lt; std::string, torch::Tensor &gt; &amp;inputMap)</td></tr>
<tr class="separator:a610469447ea8a72912d9ba0117809363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbca4648d964a43337ac3829f431d32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a5fbca4648d964a43337ac3829f431d32">insert_transition</a> (std::map&lt; std::string, torch::Tensor &gt; &amp;inputMap)</td></tr>
<tr class="separator:a5fbca4648d964a43337ac3829f431d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5284a2ebc2e6253db04d450cfc9aeb44"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a5284a2ebc2e6253db04d450cfc9aeb44">policy_output_at</a> (int64_t index)</td></tr>
<tr class="separator:a5284a2ebc2e6253db04d450cfc9aeb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f5e3e39a9974917467287f696855f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#ab8f5e3e39a9974917467287f696855f4">set_transitions_iterator</a> (int64_t batchSize)</td></tr>
<tr class="separator:ab8f5e3e39a9974917467287f696855f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e49743312b416b8434d6b45cdd92d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a093e49743312b416b8434d6b45cdd92d">size_policy_outputs</a> ()</td></tr>
<tr class="separator:a093e49743312b416b8434d6b45cdd92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9d2cbccfe1125bbfca61f1f96a0819"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a5a9d2cbccfe1125bbfca61f1f96a0819">size_transitions</a> ()</td></tr>
<tr class="separator:a5a9d2cbccfe1125bbfca61f1f96a0819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8560d499a1e55925018289c07387cd1d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a8560d499a1e55925018289c07387cd1d">transition_at</a> (int64_t index)</td></tr>
<tr class="separator:a8560d499a1e55925018289c07387cd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f54e17e15693a455a89aa8fc92a6691"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a1f54e17e15693a455a89aa8fc92a6691">~C_RolloutBuffer</a> ()</td></tr>
<tr class="separator:a1f54e17e15693a455a89aa8fc92a6691"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac9e6678c42bbeb1edcdc95cf4d8aae6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; torch::Tensor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#ac9e6678c42bbeb1edcdc95cf4d8aae6e">gather_with_process_group_</a> (torch::Tensor &amp;inputTensor)</td></tr>
<tr class="separator:ac9e6678c42bbeb1edcdc95cf4d8aae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa952e1995359f83c80ca914ed3d4d9e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">DataLoader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#aa952e1995359f83c80ca914ed3d4d9e6">dataloader_</a> = nullptr</td></tr>
<tr class="memdesc:aa952e1995359f83c80ca914ed3d4d9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DataLoader object. This is initialized to nullptr until <code>set_transitions_iterator</code> is called.  <a href="class_c___rollout_buffer.html#aa952e1995359f83c80ca914ed3d4d9e6">More...</a><br /></td></tr>
<tr class="separator:aa952e1995359f83c80ca914ed3d4d9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227cf506fd45c481bd091bd28d9240f"><td class="memItemLeft" align="right" valign="top">c10::intrusive_ptr&lt; c10d::ProcessGroup &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a1227cf506fd45c481bd091bd28d9240f">processGroup_</a></td></tr>
<tr class="memdesc:a1227cf506fd45c481bd091bd28d9240f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The intrusive pointer to ProcessGroup in PyTorch.  <a href="class_c___rollout_buffer.html#a1227cf506fd45c481bd091bd28d9240f">More...</a><br /></td></tr>
<tr class="separator:a1227cf506fd45c481bd091bd28d9240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab341d2908b3beef02dc8679fc4a7e4e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_rollout_buffer_container.html">RolloutBufferContainer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#ab341d2908b3beef02dc8679fc4a7e4e6">rolloutBufferContainer_</a></td></tr>
<tr class="memdesc:ab341d2908b3beef02dc8679fc4a7e4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to dynamically allocated <a class="el" href="class_rollout_buffer_container.html" title="The class RolloutBufferContainer is the main backend container that is used in C_RolloutBuffer....">RolloutBufferContainer</a> object.  <a href="class_c___rollout_buffer.html#ab341d2908b3beef02dc8679fc4a7e4e6">More...</a><br /></td></tr>
<tr class="separator:ab341d2908b3beef02dc8679fc4a7e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321dd6b9f34f49dfa2639cfe34f13974"><td class="memItemLeft" align="right" valign="top">torch::TensorOptions&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a321dd6b9f34f49dfa2639cfe34f13974">tensorOptions_</a></td></tr>
<tr class="memdesc:a321dd6b9f34f49dfa2639cfe34f13974"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor options to be used for PyTorch tensors; constructed with device_ and dtype_.  <a href="class_c___rollout_buffer.html#a321dd6b9f34f49dfa2639cfe34f13974">More...</a><br /></td></tr>
<tr class="separator:a321dd6b9f34f49dfa2639cfe34f13974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00863f460d299d33ac0fa0cd66bfdcaa"><td class="memItemLeft" align="right" valign="top">std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c___rollout_buffer.html#a00863f460d299d33ac0fa0cd66bfdcaa">workTimeoutDuration_</a> = std::chrono::milliseconds( 900000 )</td></tr>
<tr class="memdesc:a00863f460d299d33ac0fa0cd66bfdcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The chrono duration for work timeout to wait for all processes to complete <code>gather</code>.  <a href="class_c___rollout_buffer.html#a00863f460d299d33ac0fa0cd66bfdcaa">More...</a><br /></td></tr>
<tr class="separator:a00863f460d299d33ac0fa0cd66bfdcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >The class <a class="el" href="class_c___rollout_buffer.html" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer....">C_RolloutBuffer</a> is the class that implements the C++ backend for Rollout Buffer. Tensors are moved to C++ backend via PyBind11 and are kept opaque with std::map, hence, tensors are moved between Python and C++ only by references. <code><a class="el" href="class_c___rollout_buffer.html" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer....">C_RolloutBuffer</a></code> is hence autograd safe. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2369413382be0e3418db567c04d3b5cd" name="a2369413382be0e3418db567c04d3b5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2369413382be0e3418db567c04d3b5cd">&#9670;&#160;</a></span>DataLoader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">C_RolloutBuffer::DataLoader</a> =  torch::disable_if_t&lt; false, std::unique_ptr&lt;torch::data::StatelessDataLoader&lt; torch::data::datasets::MapDataset&lt;<a class="el" href="class_rollout_buffer_batch.html">RolloutBufferBatch</a>, <a class="el" href="class_rollout_buffer_batch_transform.html">RolloutBufferBatchTransform</a>&gt;, torch::data::samplers::SequentialSampler&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Torch DataLoader unique pointer type for RolloutBuffer. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a244889898ec240c4d2aef923dbbf2ea3" name="a244889898ec240c4d2aef923dbbf2ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244889898ec240c4d2aef923dbbf2ea3">&#9670;&#160;</a></span>C_RolloutBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C_RolloutBuffer::C_RolloutBuffer </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, c10::intrusive_ptr&lt; c10d::ProcessGroup &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>processGroupMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; int32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>workTimeoutDuration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Class constructor for <a class="el" href="class_c___rollout_buffer.html" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer....">C_RolloutBuffer</a>. This will allocate necessary memory as per input, and set relevant attributes. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a1bbfe14e6e15b7b5c7fdfb024f5fdaf2" title="Initialization method for RolloutBuffer.">rlpack._C.rollout_buffer.RolloutBuffer.__init__</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferSize</td><td>The buffer size to be used. </td></tr>
    <tr><td class="paramname">device</td><td>The device on which PyTorch tensors are to be processed. </td></tr>
    <tr><td class="paramname">dtype</td><td>The datatype which is to be used for PyTorch tensors. </td></tr>
    <tr><td class="paramname">processGroupMap</td><td>The map of process group's intrusive pointer from Python to perform collective operations if required. If the RolloutBuffer is not being used in distributed setting, this can be passed as a map of nullptr like: {{"process_group", nullptr}}. This map must contain the ProcessGroup with the key <code>process_group</code>. A map is being used to take <code>TensorMap</code> objected which is opaque and binded to avoid casting and easy pass by reference. </td></tr>
    <tr><td class="paramname">workTimeoutDuration</td><td>If a valid <code>processGroupMap</code> is being passed, this argument is relevant and indicates the work timeout duration in minutes. The work instrusive pointer explicitly calls wait to ensure synchronization. Default is set to 30 seconds.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f54e17e15693a455a89aa8fc92a6691" name="a1f54e17e15693a455a89aa8fc92a6691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f54e17e15693a455a89aa8fc92a6691">&#9670;&#160;</a></span>~C_RolloutBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C_RolloutBuffer::~C_RolloutBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Default destructor <a class="el" href="class_c___rollout_buffer.html" title="The class C_RolloutBuffer is the class that implements the C++ backend for Rollout Buffer....">C_RolloutBuffer</a>. This deletes the rolloutBufferContainer_ and deallocates the memory.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6688e63ed6b81b72e324097e306415f0" name="a6688e63ed6b81b72e324097e306415f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6688e63ed6b81b72e324097e306415f0">&#9670;&#160;</a></span>clear_policy_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void C_RolloutBuffer::clear_policy_outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the policy output vectors. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#ae2c1db5ce9ac71a1b1afdb35611417dc" title="Clears the accumulated policy outputs so far.">rlpack._C.rollout_buffer.RolloutBuffer.clear_policy_outputs</a>.</p>

</div>
</div>
<a id="a3d7329ae83788c6abdfd97e7bf65d24f" name="a3d7329ae83788c6abdfd97e7bf65d24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7329ae83788c6abdfd97e7bf65d24f">&#9670;&#160;</a></span>clear_transitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void C_RolloutBuffer::clear_transitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the transition vectors. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a5a997316c47608efc76b73cd313af5b1" title="Clears the accumulated transitions so far.">rlpack._C.rollout_buffer.RolloutBuffer.clear_transitions</a>.</p>

</div>
</div>
<a id="a8d66284b9689a3e1582e742d091a71fb" name="a8d66284b9689a3e1582e742d091a71fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d66284b9689a3e1582e742d091a71fb">&#9670;&#160;</a></span>compute_discounted_td_residuals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::compute_discounted_td_residuals </td>
          <td>(</td>
          <td class="paramtype">float_t&#160;</td>
          <td class="paramname"><em>gamma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the discounted TD residuals for the given gamma. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a7c26bf9259ab426c3aa964d2eafda5c3" title="Computes the TD residual error for state values accumulated so far given the gamma.">rlpack._C.rollout_buffer.RolloutBuffer.compute_discounted_td_residuals</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>The discounting factor value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tensor map with key "td_residuals" and corresponding TD residual values.</dd></dl>

</div>
</div>
<a id="a7edf043bd971020b94de504d1861d300" name="a7edf043bd971020b94de504d1861d300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edf043bd971020b94de504d1861d300">&#9670;&#160;</a></span>compute_generalized_advantage_estimates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::compute_generalized_advantage_estimates </td>
          <td>(</td>
          <td class="paramtype">float_t&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&#160;</td>
          <td class="paramname"><em>gaeLambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the Generalized Advantage Estimates; a bias-variance tradeoff. This is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a013685fde05baa8e9f6766606150a8cf" title="Computes the Generalized Advantage Estimate (GAE) for given gamma and lambda.">rlpack._C.rollout_buffer.RolloutBuffer.compute_generalized_advantage_estimates</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>The discounting factor value. </td></tr>
    <tr><td class="paramname">gaeLambda</td><td>The GAE Lambda value which controls the bias-variance tradeoff. When gaeLambda is 1, classic advantage is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tensor map with key "advantages" and corresponding tensor of advantages.</dd></dl>

</div>
</div>
<a id="aeb2ac0c8ffb12fb423b851013134e8be" name="aeb2ac0c8ffb12fb423b851013134e8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2ac0c8ffb12fb423b851013134e8be">&#9670;&#160;</a></span>compute_returns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::compute_returns </td>
          <td>(</td>
          <td class="paramtype">float_t&#160;</td>
          <td class="paramname"><em>gamma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the returns with accumulated rewards. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a3d35ed3f25039b34edc6e7da20f24481" title="Computes the returns for the rewards accumulated so far given the gamma.">rlpack._C.rollout_buffer.RolloutBuffer.compute_returns</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>The discounting factor to be used for computing rewards. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of returns, keyed "returns"</dd></dl>

</div>
</div>
<a id="a6e4541bcd75daf31012ea961f3b5316b" name="a6e4541bcd75daf31012ea961f3b5316b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4541bcd75daf31012ea961f3b5316b">&#9670;&#160;</a></span>extend_transitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void C_RolloutBuffer::extend_transitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This method extends the transitions by performing gather for transition quantities. This method will throw a runtime error if process group is not defined. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a9d61053d9e8d7f6883e8a2e53c79303e" title="Method to extend the transitions.">rlpack._C.rollout_buffer.RolloutBuffer.extend_transitions</a>.</p>

</div>
</div>
<a id="ac9e6678c42bbeb1edcdc95cf4d8aae6e" name="ac9e6678c42bbeb1edcdc95cf4d8aae6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e6678c42bbeb1edcdc95cf4d8aae6e">&#9670;&#160;</a></span>gather_with_process_group_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; torch::Tensor &gt; C_RolloutBuffer::gather_with_process_group_ </td>
          <td>(</td>
          <td class="paramtype">torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>inputTensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Performs gather with the initialized process group. This method will throw a runtime error if process group is not defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputTensor</td><td>: The input tensor which is to be used for input in gather. This tensor is broadcasted to other processes in the group and receives the same tensor instances from other groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: A vector of tensors is returned from groups. The vector will have tensors from other processes only and will be unbinded.</dd></dl>

</div>
</div>
<a id="a2dbf19066e59d0fd0639d129a8304d79" name="a2dbf19066e59d0fd0639d129a8304d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbf19066e59d0fd0639d129a8304d79">&#9670;&#160;</a></span>get_action_log_probabilities_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_action_log_probabilities_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the statistics for accumulated action log probabilities. Statistics are computed across each action dimension. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a5a7574db2b67612ce72d074865a4bed6" title="The method to get statistics for accumulated action log probabilities.">rlpack._C.rollout_buffer.RolloutBuffer.get_action_log_probabilities_statistics</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensors of statistics. The following keys are presents:<ul>
<li>min: The minimum value across each action dimension.</li>
<li>max: The maximum value across each action dimension.</li>
<li>mean: The mean value across each action dimension.</li>
<li>std: The std value across each action dimension.</li>
</ul>
</dd></dl>

</div>
</div>
<a id="af9ce17ba7cf35388670e89fd4d8cd311" name="af9ce17ba7cf35388670e89fd4d8cd311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce17ba7cf35388670e89fd4d8cd311">&#9670;&#160;</a></span>get_advantage_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_advantage_statistics </td>
          <td>(</td>
          <td class="paramtype">float_t&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float_t&#160;</td>
          <td class="paramname"><em>gae_lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the statistics for computed advantage. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a83e39ad2266498ea9572b52f7db91b09" title="The method to compute statistics for computed advantages.">rlpack._C.rollout_buffer.RolloutBuffer.get_advantage_statistics</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensors of statistics. The following keys are presents:<ul>
<li>min: The minimum value.</li>
<li>max: The maximum value.</li>
<li>mean: The mean value.</li>
<li>std: The std value.</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a59b0c0ef25050dd36acffff7e92b3999" name="a59b0c0ef25050dd36acffff7e92b3999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b0c0ef25050dd36acffff7e92b3999">&#9670;&#160;</a></span>get_dataloader_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">C_RolloutBuffer::DataLoader</a> &amp; C_RolloutBuffer::get_dataloader_reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the reference to private attribute dataloader_. Note that dataloader_ is a unique_ptr and hence implicit copy is not allowed. This method must not be called before <code>set_transitions_iterator</code> else an uninitialized reference might be returned. This method is used to bind dataloader_ iterator in python via pybind11.</p>

</div>
</div>
<a id="a8703acf21b67108244b091f4cb39fff8" name="a8703acf21b67108244b091f4cb39fff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8703acf21b67108244b091f4cb39fff8">&#9670;&#160;</a></span>get_entropy_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_entropy_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the statistics for entropies. Statistics are computed across each action dimension. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a55f0d93845851d4184accf310a1bff33" title="The method to get statistics for accumulated entropies.">rlpack._C.rollout_buffer.RolloutBuffer.get_entropy_statistics</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensors of statistics. The following keys are presents:<ul>
<li>min: The minimum value across each action dimension.</li>
<li>max: The maximum value across each action dimension.</li>
<li>mean: The mean value across each action dimension.</li>
<li>std: The std value across each action dimension.</li>
</ul>
</dd></dl>

</div>
</div>
<a id="aeb842c456059fb4eacb728259f197c1d" name="aeb842c456059fb4eacb728259f197c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb842c456059fb4eacb728259f197c1d">&#9670;&#160;</a></span>get_stacked_action_log_probabilities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_action_log_probabilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated action log probabilities and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a2c8746fde886cde78bafae76530f96eb" title="Gets the stacked log probabilities of action in the given distribution accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_action_log_probabilities</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of log of action probabilities, keyed "action_log_probabilities".</dd></dl>

</div>
</div>
<a id="ae867164b2f37aaa3becb98869e2e769f" name="ae867164b2f37aaa3becb98869e2e769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae867164b2f37aaa3becb98869e2e769f">&#9670;&#160;</a></span>get_stacked_dones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_dones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated dones and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#ad0edf8b78a7986a94dfe09223cff359f" title="Gets the stacked dones accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_dones</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of dones, keyed "dones".</dd></dl>

</div>
</div>
<a id="ac6db4b52e8668ec29c03ce694670bd06" name="ac6db4b52e8668ec29c03ce694670bd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6db4b52e8668ec29c03ce694670bd06">&#9670;&#160;</a></span>get_stacked_entropies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_entropies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated current entropies and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a5269bbb54d77fed8262c637a22c020ae" title="Gets the stacked entropies accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_entropies</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of entropies, keyed "entropies".</dd></dl>

</div>
</div>
<a id="a9ac46b846924e49fb0d7aa8f0e826e72" name="a9ac46b846924e49fb0d7aa8f0e826e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac46b846924e49fb0d7aa8f0e826e72">&#9670;&#160;</a></span>get_stacked_rewards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_rewards </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated rewards and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a5211c29dc8c83b71e3ac449ea831d08a" title="Gets the stacked rewards accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_rewards</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of rewards, keyed "rewards".</dd></dl>

</div>
</div>
<a id="acb4f5e54a312a96e9c37565add2af9e2" name="acb4f5e54a312a96e9c37565add2af9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4f5e54a312a96e9c37565add2af9e2">&#9670;&#160;</a></span>get_stacked_state_current_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_state_current_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated current state values and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#ab0a0e501c0994ea39fd37d52fff0d505" title="Gets the stacked current states&#39; values accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_state_current_values</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of current states, keyed "state_current_values".</dd></dl>

</div>
</div>
<a id="a8ff648bf43f074d9b01b335a06e7ffd6" name="a8ff648bf43f074d9b01b335a06e7ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff648bf43f074d9b01b335a06e7ffd6">&#9670;&#160;</a></span>get_stacked_state_next_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_state_next_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated next state values and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a248ca1e8ea8fc525c6494d776c3dc186" title="Gets the stacked next states&#39; values accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_state_next_values</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of next states, keyed "state_next_values".</dd></dl>

</div>
</div>
<a id="a373ba6bdf959906f03049935ab009b73" name="a373ba6bdf959906f03049935ab009b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373ba6bdf959906f03049935ab009b73">&#9670;&#160;</a></span>get_stacked_states_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_states_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated states current and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#aae022f5d411a1599e1496df1761058b0" title="Gets the stacked states current accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_states_current</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of states current, keyed "states_current".</dd></dl>

</div>
</div>
<a id="a857c91f65f5ff1472b229df37d3b4266" name="a857c91f65f5ff1472b229df37d3b4266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857c91f65f5ff1472b229df37d3b4266">&#9670;&#160;</a></span>get_stacked_states_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_stacked_states_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Stacks the accumulated states current and moves them to correct tensor options (for device and datatype). This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a3f92647c654eacd733370debdb9ca809" title="Gets the stacked states next accumulated so far.">rlpack._C.rollout_buffer.RolloutBuffer.get_stacked_states_next</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensor of states next, keyed "states_next".</dd></dl>

</div>
</div>
<a id="a3e8f798966744c77a3bc2adf046e11f0" name="a3e8f798966744c77a3bc2adf046e11f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8f798966744c77a3bc2adf046e11f0">&#9670;&#160;</a></span>get_state_values_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_state_values_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the statistics for accumulated state values. Both state current values and state next values are used for statistics computation. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#ab549c345f230a4afb9fc56eea44b064d" title="The method to compute statistics for accumulated state values (both state_current_values and state_ne...">rlpack._C.rollout_buffer.RolloutBuffer.get_state_values_statistics</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensors of statistics. The following keys are presents:<ul>
<li>min: The minimum value.</li>
<li>max: The maximum value.</li>
<li>mean: The mean value.</li>
<li>std: The std value.</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8fb048dff5319659dfaa225eabe33838" name="a8fb048dff5319659dfaa225eabe33838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb048dff5319659dfaa225eabe33838">&#9670;&#160;</a></span>get_states_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::get_states_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the statistics for accumulated states. Both states current and states next are used for computing the statistics. The statistics are computed along each state dimension. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a53050afcba5e21b94bd9c1042365baf1" title="The method to get statistics for accumulated states (both states_current and states_next are used for...">rlpack._C.rollout_buffer.RolloutBuffer.get_states_statistics</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A map of PyTorch tensors of statistics. The following keys are presents:<ul>
<li>min: The minimum value across each state dimension.</li>
<li>max: The maximum value across each state dimension.</li>
<li>mean: The mean value across each state dimension.</li>
<li>std: The std value across each state dimension.</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a610469447ea8a72912d9ba0117809363" name="a610469447ea8a72912d9ba0117809363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610469447ea8a72912d9ba0117809363">&#9670;&#160;</a></span>insert_policy_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void C_RolloutBuffer::insert_policy_output </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, torch::Tensor &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Insertion method to insert policy outputs into Rollout Buffer. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#af5c7f47065ce79d122cc61423566aa99" title="Insertion method for policy outputs in the rollout buffer.">rlpack._C.rollout_buffer.RolloutBuffer.insert_policy_output</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>The input map of tensors with quantities to insert_policy_output into the rollout buffer. The map must contain the following keys:<ul>
<li>action_log_probability: The log probability of the sampled action in the given distribution.</li>
<li>state_current_value: Current state value.</li>
<li>state_next_value: Value of next state.</li>
<li>entropy: Current entropy of the distribution.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>For more information, please refer <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html">rlpack._C.rollout_buffer.RolloutBuffer</a> and rlpack.actor_critic.base.ActorCriticAgent</p>

</div>
</div>
<a id="a5fbca4648d964a43337ac3829f431d32" name="a5fbca4648d964a43337ac3829f431d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbca4648d964a43337ac3829f431d32">&#9670;&#160;</a></span>insert_transition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void C_RolloutBuffer::insert_transition </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, torch::Tensor &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Insertion method to insert transitions into Rollout Buffer. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#ab5e05d6a3c8329550b96b9b6a777ece0" title="Insertion method for transitions to the rollout buffer.">rlpack._C.rollout_buffer.RolloutBuffer.insert_transition</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputMap</td><td>The input map of tensors with quantities to insert into the rollout buffer. The map must contain the following keys:<ul>
<li>state_current: The current state.</li>
<li>state_next: The next state.</li>
<li>done: The current done flag for episode termination/truncation.</li>
<li>reward: The reward obtained by the agent.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>For more information, please refer <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html">rlpack._C.rollout_buffer.RolloutBuffer</a> and rlpack.actor_critic.base.ActorCriticAgent</p>

</div>
</div>
<a id="a5284a2ebc2e6253db04d450cfc9aeb44" name="a5284a2ebc2e6253db04d450cfc9aeb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5284a2ebc2e6253db04d450cfc9aeb44">&#9670;&#160;</a></span>policy_output_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::policy_output_at </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Obtain the policy output at a given index. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a50a85f7018c55f12afd46ef2ee1424fe" title="Returns the policy outputs at a given index.">rlpack._C.rollout_buffer.RolloutBuffer.policy_output_at</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>: The index of the policy output buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The map with policy output quantities viz:<ul>
<li>action_log_probability</li>
<li>state_current_value</li>
<li>state_next_value</li>
<li>entropy</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab8f5e3e39a9974917467287f696855f4" name="ab8f5e3e39a9974917467287f696855f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f5e3e39a9974917467287f696855f4">&#9670;&#160;</a></span>set_transitions_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void C_RolloutBuffer::set_transitions_iterator </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>batchSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A utility method which is used to set the private attribute dataloader_ with appropriate dataloader. This method creates the MapDataset and wraps it with SequentialSampler to create the dataloader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batchSize</td><td>The batch size to be used to batchify the transitions.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a093e49743312b416b8434d6b45cdd92d" name="a093e49743312b416b8434d6b45cdd92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e49743312b416b8434d6b45cdd92d">&#9670;&#160;</a></span>size_policy_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t C_RolloutBuffer::size_policy_outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the size of Rollout Buffer. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#ac721a40d2f2a14d9cfc97414c35d753c" title="Returns the size of policy output buffer.">rlpack._C.rollout_buffer.RolloutBuffer.size_policy_outputs</a>.</p>

</div>
</div>
<a id="a5a9d2cbccfe1125bbfca61f1f96a0819" name="a5a9d2cbccfe1125bbfca61f1f96a0819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9d2cbccfe1125bbfca61f1f96a0819">&#9670;&#160;</a></span>size_transitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t C_RolloutBuffer::size_transitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the size of Rollout Buffer. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a22bfb0ddbbf0ab8243235fd72d0844e2" title="Returns the size of transition buffer.">rlpack._C.rollout_buffer.RolloutBuffer.size_transitions</a>.</p>

</div>
</div>
<a id="a8560d499a1e55925018289c07387cd1d" name="a8560d499a1e55925018289c07387cd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8560d499a1e55925018289c07387cd1d">&#9670;&#160;</a></span>transition_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, torch::Tensor &gt; C_RolloutBuffer::transition_at </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Obtain the transitions at a given index. This method is C++ backend for <a class="el" href="classrlpack_1_1___c_1_1rollout__buffer_1_1_rollout_buffer.html#a5c5da53655a9f67e17d4ee5807c0ed3b" title="Returns the transitions at a given index.">rlpack._C.rollout_buffer.RolloutBuffer.transition_at</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>: The index of the transitions buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: The map with transitions quantities viz:<ul>
<li>state_current</li>
<li>state_next</li>
<li>reward</li>
<li>done</li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="aa952e1995359f83c80ca914ed3d4d9e6" name="aa952e1995359f83c80ca914ed3d4d9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa952e1995359f83c80ca914ed3d4d9e6">&#9670;&#160;</a></span>dataloader_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c___rollout_buffer.html#a2369413382be0e3418db567c04d3b5cd">DataLoader</a> C_RolloutBuffer::dataloader_ = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The DataLoader object. This is initialized to nullptr until <code>set_transitions_iterator</code> is called. </p>

</div>
</div>
<a id="a1227cf506fd45c481bd091bd28d9240f" name="a1227cf506fd45c481bd091bd28d9240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1227cf506fd45c481bd091bd28d9240f">&#9670;&#160;</a></span>processGroup_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">c10::intrusive_ptr&lt;c10d::ProcessGroup&gt; C_RolloutBuffer::processGroup_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The intrusive pointer to ProcessGroup in PyTorch. </p>

</div>
</div>
<a id="ab341d2908b3beef02dc8679fc4a7e4e6" name="ab341d2908b3beef02dc8679fc4a7e4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab341d2908b3beef02dc8679fc4a7e4e6">&#9670;&#160;</a></span>rolloutBufferContainer_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_rollout_buffer_container.html">RolloutBufferContainer</a>* C_RolloutBuffer::rolloutBufferContainer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pointer to dynamically allocated <a class="el" href="class_rollout_buffer_container.html" title="The class RolloutBufferContainer is the main backend container that is used in C_RolloutBuffer....">RolloutBufferContainer</a> object. </p>

</div>
</div>
<a id="a321dd6b9f34f49dfa2639cfe34f13974" name="a321dd6b9f34f49dfa2639cfe34f13974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321dd6b9f34f49dfa2639cfe34f13974">&#9670;&#160;</a></span>tensorOptions_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">torch::TensorOptions C_RolloutBuffer::tensorOptions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The tensor options to be used for PyTorch tensors; constructed with device_ and dtype_. </p>

</div>
</div>
<a id="a00863f460d299d33ac0fa0cd66bfdcaa" name="a00863f460d299d33ac0fa0cd66bfdcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00863f460d299d33ac0fa0cd66bfdcaa">&#9670;&#160;</a></span>workTimeoutDuration_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::milliseconds C_RolloutBuffer::workTimeoutDuration_ = std::chrono::milliseconds( 900000 )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The chrono duration for work timeout to wait for all processes to complete <code>gather</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_c___rollout_buffer.html">C_RolloutBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
