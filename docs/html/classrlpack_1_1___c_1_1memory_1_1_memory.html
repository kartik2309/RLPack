<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RLPack: rlpack._C.memory.Memory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="RLPack-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">RLPack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrlpack_1_1___c_1_1memory_1_1_memory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classrlpack_1_1___c_1_1memory_1_1_memory-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rlpack._C.memory.Memory Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for rlpack._C.memory.Memory:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classrlpack_1_1___c_1_1memory_1_1_memory.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e3c497fa06a08db21c0c9fcfa0f6558"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a8e3c497fa06a08db21c0c9fcfa0f6558">__delitem__</a> (self, int index)</td></tr>
<tr class="separator:a8e3c497fa06a08db21c0c9fcfa0f6558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f974de3e3b20fef052431876483cd16"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a0f974de3e3b20fef052431876483cd16">__getattr__</a> (self, str item)</td></tr>
<tr class="separator:a0f974de3e3b20fef052431876483cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae58a8c992754dd3b27177e2ab17d49b"><td class="memItemLeft" align="right" valign="top">List[pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#aae58a8c992754dd3b27177e2ab17d49b">__getitem__</a> (self, int index)</td></tr>
<tr class="separator:aae58a8c992754dd3b27177e2ab17d49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b5bd87e3aa3af00b53a2d3599f6bc1"><td class="memItemLeft" align="right" valign="top">Dict[str, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#ab6b5bd87e3aa3af00b53a2d3599f6bc1">__getstate__</a> (self)</td></tr>
<tr class="separator:ab6b5bd87e3aa3af00b53a2d3599f6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1b564e1db43263e61fc17a4b9c31af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#aae1b564e1db43263e61fc17a4b9c31af">__init__</a> (self, Optional[int] buffer_size=32768, Optional[str] device=&quot;cpu&quot;, int prioritization_strategy_code=0, int batch_size=32)</td></tr>
<tr class="separator:aae1b564e1db43263e61fc17a4b9c31af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e8863b915b92c30e7e9e93c5e1c005"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a82e8863b915b92c30e7e9e93c5e1c005">__len__</a> (self)</td></tr>
<tr class="separator:a82e8863b915b92c30e7e9e93c5e1c005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b8a13384e2aa7a66bc96bfba0ee262"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a38b8a13384e2aa7a66bc96bfba0ee262">__repr__</a> (self)</td></tr>
<tr class="separator:a38b8a13384e2aa7a66bc96bfba0ee262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a955ff4ec401bb513f88eb8fb4ad3d3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a4a955ff4ec401bb513f88eb8fb4ad3d3">__setattr__</a> (self, str key, Any value)</td></tr>
<tr class="separator:a4a955ff4ec401bb513f88eb8fb4ad3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b07520076b2bc0ad80b72d61d6afc3"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a20b07520076b2bc0ad80b72d61d6afc3">__setitem__</a> (self, int index, Tuple[Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]], Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]], Union[np.ndarray, float], Union[np.ndarray, float], Union[bool, int], Union[pytorch.Tensor, np.ndarray, float], Union[pytorch.Tensor, np.ndarray, float], Union[pytorch.Tensor, np.ndarray, float],] transition)</td></tr>
<tr class="separator:a20b07520076b2bc0ad80b72d61d6afc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b92a58bd9415030755614ea6ef0d56"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a45b92a58bd9415030755614ea6ef0d56">__setstate__</a> (self, Dict[str, Any] state)</td></tr>
<tr class="separator:a45b92a58bd9415030755614ea6ef0d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40df31187dc9ec40b9c286c40ab690b"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#aa40df31187dc9ec40b9c286c40ab690b">__str__</a> (self)</td></tr>
<tr class="separator:aa40df31187dc9ec40b9c286c40ab690b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf783f61b1be01a149bf9dc3d7ac90f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#abaf783f61b1be01a149bf9dc3d7ac90f">clear</a> (self)</td></tr>
<tr class="separator:abaf783f61b1be01a149bf9dc3d7ac90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3685dbf64ef7a52f40b88aa9c2df01d9"><td class="memItemLeft" align="right" valign="top">List[pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a3685dbf64ef7a52f40b88aa9c2df01d9">get_actions</a> (self)</td></tr>
<tr class="separator:a3685dbf64ef7a52f40b88aa9c2df01d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f112e1289b882ef9739ca89a1a51838"><td class="memItemLeft" align="right" valign="top">List[pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a3f112e1289b882ef9739ca89a1a51838">get_dones</a> (self)</td></tr>
<tr class="separator:a3f112e1289b882ef9739ca89a1a51838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041457374f7e60d9394eb3383bf34aac"><td class="memItemLeft" align="right" valign="top">List[float]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a041457374f7e60d9394eb3383bf34aac">get_priorities</a> (self)</td></tr>
<tr class="separator:a041457374f7e60d9394eb3383bf34aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc192c7fc54841274f3bf5f800bad608"><td class="memItemLeft" align="right" valign="top">List[pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#acc192c7fc54841274f3bf5f800bad608">get_rewards</a> (self)</td></tr>
<tr class="separator:acc192c7fc54841274f3bf5f800bad608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d57b56fafcb0eae202ed5de8c09631b"><td class="memItemLeft" align="right" valign="top">List[pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a1d57b56fafcb0eae202ed5de8c09631b">get_states_current</a> (self)</td></tr>
<tr class="separator:a1d57b56fafcb0eae202ed5de8c09631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9e43c7a695618d85a69aeb668e5d3f"><td class="memItemLeft" align="right" valign="top">List[pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#adb9e43c7a695618d85a69aeb668e5d3f">get_states_next</a> (self)</td></tr>
<tr class="separator:adb9e43c7a695618d85a69aeb668e5d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db9cfb35402b28d7e557813e220c44"><td class="memItemLeft" align="right" valign="top">List[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a56db9cfb35402b28d7e557813e220c44">get_terminal_state_indices</a> (self)</td></tr>
<tr class="separator:a56db9cfb35402b28d7e557813e220c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7f91902d5de7853c3f1c0061ef522"><td class="memItemLeft" align="right" valign="top">Dict[str, pytorch.Tensor]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#ad3a7f91902d5de7853c3f1c0061ef522">get_transitions</a> (self)</td></tr>
<tr class="separator:ad3a7f91902d5de7853c3f1c0061ef522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05868f1c95b791df02e6a801e689659f"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a05868f1c95b791df02e6a801e689659f">initialize</a> (self, C_Memory.C_MemoryData memory_data)</td></tr>
<tr class="separator:a05868f1c95b791df02e6a801e689659f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab563541fe4901f5cdfab4b763f270e1"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#aab563541fe4901f5cdfab4b763f270e1">insert</a> (self, Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]] state_current, Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]] state_next, Union[np.ndarray, float] reward, Union[np.ndarray, float] action, Union[bool, int] done, Optional[Union[pytorch.Tensor, np.ndarray, float]] priority=1.0, Optional[Union[pytorch.Tensor, np.ndarray, float]] probability=1.0, Optional[Union[pytorch.Tensor, np.ndarray, float]] weight=1.0)</td></tr>
<tr class="separator:aab563541fe4901f5cdfab4b763f270e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfd56ab54b01a3d2ecc0c0b7a3f3f91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a1cfd56ab54b01a3d2ecc0c0b7a3f3f91">num_terminal_states</a> (self)</td></tr>
<tr class="separator:a1cfd56ab54b01a3d2ecc0c0b7a3f3f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d90610de2b8d351dfa7c6cea669d5ca"><td class="memItemLeft" align="right" valign="top">Tuple[ pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor,]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a4d90610de2b8d351dfa7c6cea669d5ca">sample</a> (self, float force_terminal_state_probability=0.0, int parallelism_size_threshold=4096, float alpha=0.0, float beta=0.0, int num_segments=1)</td></tr>
<tr class="separator:a4d90610de2b8d351dfa7c6cea669d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195e5f54ce28d0c2d7b6ea0ddf5f15ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a195e5f54ce28d0c2d7b6ea0ddf5f15ff">tree_height</a> (self)</td></tr>
<tr class="separator:a195e5f54ce28d0c2d7b6ea0ddf5f15ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae046ade4691f2accb1cd74383d03b46c"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#ae046ade4691f2accb1cd74383d03b46c">update_priorities</a> (self, pytorch.Tensor random_indices, pytorch.Tensor new_priorities, pytorch.Tensor new_probabilities, pytorch.Tensor new_weights)</td></tr>
<tr class="separator:ae046ade4691f2accb1cd74383d03b46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d6fb2acaa293da125fefe9f4c14859"><td class="memItemLeft" align="right" valign="top">C_Memory.C_MemoryData&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a95d6fb2acaa293da125fefe9f4c14859">view</a> (self)</td></tr>
<tr class="separator:a95d6fb2acaa293da125fefe9f4c14859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a22d35108cb7dd3c186fe79ddc369aad9"><td class="memItemLeft" align="right" valign="top"><a id="a22d35108cb7dd3c186fe79ddc369aad9" name="a22d35108cb7dd3c186fe79ddc369aad9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_size</b></td></tr>
<tr class="separator:a22d35108cb7dd3c186fe79ddc369aad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f415e9920c3628e9bb5d6ffd0673ab"><td class="memItemLeft" align="right" valign="top"><a id="ae0f415e9920c3628e9bb5d6ffd0673ab" name="ae0f415e9920c3628e9bb5d6ffd0673ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>c_memory</b></td></tr>
<tr class="separator:ae0f415e9920c3628e9bb5d6ffd0673ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7670dc2d5a5f6cf6cedd5d840310d04"><td class="memItemLeft" align="right" valign="top"><a id="ac7670dc2d5a5f6cf6cedd5d840310d04" name="ac7670dc2d5a5f6cf6cedd5d840310d04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>device</b></td></tr>
<tr class="separator:ac7670dc2d5a5f6cf6cedd5d840310d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777162c561cd1e9b8249464920a8e11f"><td class="memItemLeft" align="right" valign="top"><a id="a777162c561cd1e9b8249464920a8e11f" name="a777162c561cd1e9b8249464920a8e11f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>prioritization_strategy_code</b></td></tr>
<tr class="separator:a777162c561cd1e9b8249464920a8e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a62da4039247bd7d808c1c98a9c8216db"><td class="memItemLeft" align="right" valign="top">Tuple[ pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, pytorch.Tensor, bool,]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html#a62da4039247bd7d808c1c98a9c8216db">__prepare_inputs_c_memory_</a> (Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]] state_current, Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]] state_next, Union[pytorch.Tensor, np.ndarray, float] reward, Union[pytorch.Tensor, np.ndarray, float] action, Union[bool, int] done, Union[pytorch.Tensor, np.ndarray, float] priority, Union[pytorch.Tensor, np.ndarray, float] probability, Union[pytorch.Tensor, np.ndarray, float] weight)</td></tr>
<tr class="separator:a62da4039247bd7d808c1c98a9c8216db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">This class provides the python interface to C_Memory, the C++ class which performs heavier workloads.
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae1b564e1db43263e61fc17a4b9c31af" name="aae1b564e1db43263e61fc17a4b9c31af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1b564e1db43263e61fc17a4b9c31af">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def rlpack._C.memory.Memory.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[int] &#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>32768</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[str] &#160;</td>
          <td class="paramname"><em>device</em> = <code>&quot;cpu&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>prioritization_strategy_code</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">:param buffer_size: Optional[int]: The buffer size of the memory. No more than specified buffer
    elements are stored in the memory. Default: 32768
:param device: str: The cuda on which models are currently running. Default: "cpu".
:param prioritization_strategy_code: int: Indicates code for prioritization strategy. Default: 0.
:param batch_size: int: The batch size to be used for training cycle.
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e3c497fa06a08db21c0c9fcfa0f6558" name="a8e3c497fa06a08db21c0c9fcfa0f6558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3c497fa06a08db21c0c9fcfa0f6558">&#9670;&#160;</a></span>__delitem__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.__delitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Deletion method for memory.
:param index: int: Index at which we want to delete an item.
Note that this operation can be expensive depending on the size of memory; O(n).
</pre> 
</div>
</div>
<a id="a0f974de3e3b20fef052431876483cd16" name="a0f974de3e3b20fef052431876483cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f974de3e3b20fef052431876483cd16">&#9670;&#160;</a></span>__getattr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any rlpack._C.memory.Memory.__getattr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get attr method for memory
:param item: str: The attributes that has been set during runtime (through __setattr__).
:return: Any: The value for the item pass.
</pre> 
</div>
</div>
<a id="aae58a8c992754dd3b27177e2ab17d49b" name="aae58a8c992754dd3b27177e2ab17d49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae58a8c992754dd3b27177e2ab17d49b">&#9670;&#160;</a></span>__getitem__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[pytorch.Tensor] rlpack._C.memory.Memory.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indexing method for memory.
:param index: int: The index at which we want to obtain the memory data.
:return: List[pytorch.Tensor]: The transition as tensors from the memory.
</pre> 
</div>
</div>
<a id="ab6b5bd87e3aa3af00b53a2d3599f6bc1" name="ab6b5bd87e3aa3af00b53a2d3599f6bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b5bd87e3aa3af00b53a2d3599f6bc1">&#9670;&#160;</a></span>__getstate__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, Any] rlpack._C.memory.Memory.__getstate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get state method for memory. This makes this Memory class pickleable.
:return: Dict[str, Any]: The state of the memory.
</pre> 
</div>
</div>
<a id="a82e8863b915b92c30e7e9e93c5e1c005" name="a82e8863b915b92c30e7e9e93c5e1c005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e8863b915b92c30e7e9e93c5e1c005">&#9670;&#160;</a></span>__len__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int rlpack._C.memory.Memory.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Length method for memory.
:return: int: The size of the memory.
</pre> 
</div>
</div>
<a id="a62da4039247bd7d808c1c98a9c8216db" name="a62da4039247bd7d808c1c98a9c8216db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62da4039247bd7d808c1c98a9c8216db">&#9670;&#160;</a></span>__prepare_inputs_c_memory_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        bool,
    ] rlpack._C.memory.Memory.__prepare_inputs_c_memory_ </td>
          <td>(</td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]&#160;</td>
          <td class="paramname"><em>state_current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]&#160;</td>
          <td class="paramname"><em>state_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, float]&#160;</td>
          <td class="paramname"><em>reward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, float]&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, int]&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, float]&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, float]&#160;</td>
          <td class="paramname"><em>probability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, float]&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Prepares inputs to be sent to C++ backend.
:param state_current: Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]: The current
    state agent is in.
:param state_next: Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]: The next
    state agent will go in for the specified action.
:param reward: Union[np.ndarray, float]): The reward obtained in the transition.
:param action: Union[np.ndarray, float]): The action taken for the transition.
:param done Union[bool, int]: Indicates weather episodes ended or not, i.e.
    if state_next is a terminal state or not.
:param priority: Union[pytorch.Tensor, np.ndarray, float]): The priority of the
    transition: for priority relay memory). Default: None.
:param probability: Union[pytorch.Tensor, np.ndarray, float]): The probability of the transition
   : for priority relay memory). Default: None.
:param weight: Union[pytorch.Tensor, np.ndarray, float]): The important sampling weight
    of the transition: for priority relay memory). Default: None.
:return: Tuple[
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        bool
    ]):  The tuple of in order of: state_current, state_next, reward, action, done, priority,
     probability, weight, is_terminal_state).
     `is_terminal_state` indicates if the state is terminal state or not: corresponds to done).
    All the input values associated with transition tuple are type-casted to PyTorch Tensors.
</pre> 
</div>
</div>
<a id="a38b8a13384e2aa7a66bc96bfba0ee262" name="a38b8a13384e2aa7a66bc96bfba0ee262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b8a13384e2aa7a66bc96bfba0ee262">&#9670;&#160;</a></span>__repr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str rlpack._C.memory.Memory.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Repr method for memory.
:return: str: String with object's memory location.
</pre> 
</div>
</div>
<a id="a4a955ff4ec401bb513f88eb8fb4ad3d3" name="a4a955ff4ec401bb513f88eb8fb4ad3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a955ff4ec401bb513f88eb8fb4ad3d3">&#9670;&#160;</a></span>__setattr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.__setattr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set attr method for memory.
:param key: str: The desired attribute name.
:param value: Any: The value for corresponding key.
</pre> 
</div>
</div>
<a id="a20b07520076b2bc0ad80b72d61d6afc3" name="a20b07520076b2bc0ad80b72d61d6afc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b07520076b2bc0ad80b72d61d6afc3">&#9670;&#160;</a></span>__setitem__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.__setitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple[
            Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]],
            Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]],
            Union[np.ndarray, float],
            Union[np.ndarray, float],
            Union[bool, int],
            Union[pytorch.Tensor, np.ndarray, float],
            Union[pytorch.Tensor, np.ndarray, float],
            Union[pytorch.Tensor, np.ndarray, float],
        ]&#160;</td>
          <td class="paramname"><em>transition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set item method for the memory.
:param index: int: index to insert.
:param transition: Tuple[
        Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]],
        Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]],
        Union[np.ndarray, float],
        Union[np.ndarray, float],
        Union[bool, int],
        Union[pytorch.Tensor, np.ndarray, float],
        Union[pytorch.Tensor, np.ndarray, float],
        Union[pytorch.Tensor, np.ndarray, float]
    ]: The transition tuple in the order: state_current, state_next, reward, action, done,
     priority, probability, weight).
</pre> 
</div>
</div>
<a id="a45b92a58bd9415030755614ea6ef0d56" name="a45b92a58bd9415030755614ea6ef0d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b92a58bd9415030755614ea6ef0d56">&#9670;&#160;</a></span>__setstate__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.__setstate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dict[str, Any]&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set state method for the memory.
:param state: Dict[str, Any]: This method loads the states back to memory instance. This helps unpickle
    the Memory.
</pre> 
</div>
</div>
<a id="aa40df31187dc9ec40b9c286c40ab690b" name="aa40df31187dc9ec40b9c286c40ab690b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40df31187dc9ec40b9c286c40ab690b">&#9670;&#160;</a></span>__str__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str rlpack._C.memory.Memory.__str__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The str method for memory. Useful for printing the memory.
On calling print(memory), will print the transition information.
:return: str: The dictionary with encapsulated data of memory.
</pre> 
</div>
</div>
<a id="abaf783f61b1be01a149bf9dc3d7ac90f" name="abaf783f61b1be01a149bf9dc3d7ac90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf783f61b1be01a149bf9dc3d7ac90f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.clear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This method clear the memory and renders it empty
</pre> 
</div>
</div>
<a id="a3685dbf64ef7a52f40b88aa9c2df01d9" name="a3685dbf64ef7a52f40b88aa9c2df01d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3685dbf64ef7a52f40b88aa9c2df01d9">&#9670;&#160;</a></span>get_actions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[pytorch.Tensor] rlpack._C.memory.Memory.get_actions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the actions from transitions accumulated so far.
:return: List[pytorch.Tensor]: A list of tensors with action values.
</pre> 
</div>
</div>
<a id="a3f112e1289b882ef9739ca89a1a51838" name="a3f112e1289b882ef9739ca89a1a51838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f112e1289b882ef9739ca89a1a51838">&#9670;&#160;</a></span>get_dones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[pytorch.Tensor] rlpack._C.memory.Memory.get_dones </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the dones from transitions accumulated so far.
:return: List[pytorch.Tensor]: A list of tensors with done values.
</pre> 
</div>
</div>
<a id="a041457374f7e60d9394eb3383bf34aac" name="a041457374f7e60d9394eb3383bf34aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041457374f7e60d9394eb3383bf34aac">&#9670;&#160;</a></span>get_priorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[float] rlpack._C.memory.Memory.get_priorities </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the priorities for all the transitions, ordered by index.
:return: List[float]: A list of priorities ordered by index.
</pre> 
</div>
</div>
<a id="acc192c7fc54841274f3bf5f800bad608" name="acc192c7fc54841274f3bf5f800bad608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc192c7fc54841274f3bf5f800bad608">&#9670;&#160;</a></span>get_rewards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[pytorch.Tensor] rlpack._C.memory.Memory.get_rewards </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the rewards from transitions accumulated so far.
:return: List[pytorch.Tensor]: A list of tensors with reward values.
</pre> 
</div>
</div>
<a id="a1d57b56fafcb0eae202ed5de8c09631b" name="a1d57b56fafcb0eae202ed5de8c09631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d57b56fafcb0eae202ed5de8c09631b">&#9670;&#160;</a></span>get_states_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[pytorch.Tensor] rlpack._C.memory.Memory.get_states_current </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the current states from transitions accumulated so far.
:return: List[pytorch.Tensor]: A list of tensors with current state values.
</pre> 
</div>
</div>
<a id="adb9e43c7a695618d85a69aeb668e5d3f" name="adb9e43c7a695618d85a69aeb668e5d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9e43c7a695618d85a69aeb668e5d3f">&#9670;&#160;</a></span>get_states_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[pytorch.Tensor] rlpack._C.memory.Memory.get_states_next </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the next states from transitions accumulated so far.
:return: List[pytorch.Tensor]: A list of tensors with next state values.
</pre> 
</div>
</div>
<a id="a56db9cfb35402b28d7e557813e220c44" name="a56db9cfb35402b28d7e557813e220c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db9cfb35402b28d7e557813e220c44">&#9670;&#160;</a></span>get_terminal_state_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[int] rlpack._C.memory.Memory.get_terminal_state_indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves the terminal state indices accumulated so far.
:return: List[int]: The list of terminal state indices.
</pre> 
</div>
</div>
<a id="ad3a7f91902d5de7853c3f1c0061ef522" name="ad3a7f91902d5de7853c3f1c0061ef522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a7f91902d5de7853c3f1c0061ef522">&#9670;&#160;</a></span>get_transitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Dict[str, pytorch.Tensor] rlpack._C.memory.Memory.get_transitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This retrieves all the transitions accumulated so far.
:return: Dict[str, pytorch.Tensor]: A dictionary with all transition information.
</pre> 
</div>
</div>
<a id="a05868f1c95b791df02e6a801e689659f" name="a05868f1c95b791df02e6a801e689659f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05868f1c95b791df02e6a801e689659f">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.initialize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_Memory.C_MemoryData&#160;</td>
          <td class="paramname"><em>memory_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This loads the memory from the provided C_MemoryData instance.
:param memory_data: C_Memory.C_MemoryData: The C_MemoryData instance to load the memory form.
</pre> 
</div>
</div>
<a id="aab563541fe4901f5cdfab4b763f270e1" name="aab563541fe4901f5cdfab4b763f270e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab563541fe4901f5cdfab4b763f270e1">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.insert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]&#160;</td>
          <td class="paramname"><em>state_current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]&#160;</td>
          <td class="paramname"><em>state_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[np.ndarray, float]&#160;</td>
          <td class="paramname"><em>reward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[np.ndarray, float]&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Union[bool, int]&#160;</td>
          <td class="paramname"><em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Union[pytorch.Tensor, np.ndarray, float]] &#160;</td>
          <td class="paramname"><em>priority</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Union[pytorch.Tensor, np.ndarray, float]] &#160;</td>
          <td class="paramname"><em>probability</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Optional[Union[pytorch.Tensor, np.ndarray, float]] &#160;</td>
          <td class="paramname"><em>weight</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This method performs insertion to the memory.
:param state_current: Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]: The current
    state agent is in.
:param state_next: Union[pytorch.Tensor, np.ndarray, List[Union[float, int]]]: The next
    state agent will go in for the specified action.
:param reward: Union[np.ndarray, float]: The reward obtained in the transition.
:param action: Union[np.ndarray, float]: The action taken for the transition.
:param done: Union[bool, int]: Indicates weather episodes ended or not, i.e.
    if state_next is a terminal state or not.
:param priority: Optional[Union[pytorch.Tensor, np.ndarray, float]]: The priority of the
    transition: for priority relay memory). Default: 1.0.
:param probability: Optional[Union[pytorch.Tensor, np.ndarray, float]]: The probability of the transition
   : for priority relay memory). Default: 1.0.
:param weight: Optional[Union[pytorch.Tensor, np.ndarray, float]]: The important sampling weight
    of the transition: for priority relay memory). Default: 1.0.
</pre> 
</div>
</div>
<a id="a1cfd56ab54b01a3d2ecc0c0b7a3f3f91" name="a1cfd56ab54b01a3d2ecc0c0b7a3f3f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfd56ab54b01a3d2ecc0c0b7a3f3f91">&#9670;&#160;</a></span>num_terminal_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int rlpack._C.memory.Memory.num_terminal_states </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of terminal states.
:return: int: Num of terminal states.
</pre> 
</div>
</div>
<a id="a4d90610de2b8d351dfa7c6cea669d5ca" name="a4d90610de2b8d351dfa7c6cea669d5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d90610de2b8d351dfa7c6cea669d5ca">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
    ] rlpack._C.memory.Memory.sample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>force_terminal_state_probability</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>parallelism_size_threshold</em> = <code>4096</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>num_segments</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load random samples from memory for a given batch.
:param force_terminal_state_probability: float: The probability for forcefully selecting a terminal state
    in a batch. Default: 0.0.
:param parallelism_size_threshold: int: The minimum size of memory beyond which parallelism is used to shuffle
    and retrieve the batch of sample. Default: 4096.
:param alpha: float: The alpha value for computation of probabilities. Default: 0.0.
:param beta: float: The beta value for computation of important sampling weights. Default: 0.0.
:param num_segments: int: The number of segments to use to uniformly sample for rank-based prioritization.
:return:Tuple[
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
        pytorch.Tensor,
    ]: The tuple of tensors as:states_current, states_next, rewards, actions, dones, priorities,
    probabilities, weights, random_indices).
</pre> 
</div>
</div>
<a id="a195e5f54ce28d0c2d7b6ea0ddf5f15ff" name="a195e5f54ce28d0c2d7b6ea0ddf5f15ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195e5f54ce28d0c2d7b6ea0ddf5f15ff">&#9670;&#160;</a></span>tree_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int rlpack._C.memory.Memory.tree_height </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the height of the Sum Tree when using prioritized memory. This is only relevant when
    using prioritized buffer.
Note that tree height is given as per buffer size and not as per number of elements.
:return: int: The height of the tree.
</pre> 
</div>
</div>
<a id="ae046ade4691f2accb1cd74383d03b46c" name="ae046ade4691f2accb1cd74383d03b46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae046ade4691f2accb1cd74383d03b46c">&#9670;&#160;</a></span>update_priorities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None rlpack._C.memory.Memory.update_priorities </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pytorch.Tensor&#160;</td>
          <td class="paramname"><em>random_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pytorch.Tensor&#160;</td>
          <td class="paramname"><em>new_priorities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pytorch.Tensor&#160;</td>
          <td class="paramname"><em>new_probabilities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pytorch.Tensor&#160;</td>
          <td class="paramname"><em>new_weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This method updates the priorities when prioritized memory is used. It will also update
    associated probabilities and important sampling weights.
:param random_indices: pytorch.Tensor: The list of random indices which were sampled previously. These
    indices are used to update the corresponding values. Must be a 1-D PyTorch Tensor.
:param new_priorities: pytorch.Tensor: The list of new priorities corresponding to `random_indices` passed.
:param new_probabilities: pytorch.Tensor: The list of new probabilities corresponding to.
    `random_indices` passed.
:param new_weights: pytorch.Tensor: The list of new weights corresponding to `random_indices` passed.
</pre> 
</div>
</div>
<a id="a95d6fb2acaa293da125fefe9f4c14859" name="a95d6fb2acaa293da125fefe9f4c14859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d6fb2acaa293da125fefe9f4c14859">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> C_Memory.C_MemoryData rlpack._C.memory.Memory.view </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This method returns the view of Memory, i.e. the data stored in the memory.
@:return (C_Memory.C_MemoryData): The C_MemoryData object which packages the current memory information.
    This object is pickleable and data can also be accessed via attributes.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/kartikrajeshwaran/Library/CloudStorage/GoogleDrive-kartikrajeshwaran.kr@gmail.com/My Drive/Projects/Python/RLPack/rlpack/_C/memory.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>rlpack</b></li><li class="navelem"><b>_C</b></li><li class="navelem"><b>memory</b></li><li class="navelem"><a class="el" href="classrlpack_1_1___c_1_1memory_1_1_memory.html">Memory</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
